{"metadata":{"tool_info":{"name":"rust-analyzer","version":"0.3.255-standalone"},"project_root":"file:///home/lacra/git_repos/baif/minimal-scip-issue","text_document_encoding":1},"documents":[{"language":"rust","relative_path":"src/lib.rs","occurrences":[{"range":[8,4,7],"symbol":"local 0"},{"range":[8,9,12],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core ops/"},{"range":[8,15,18],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Mul#"},{"range":[8,20,23],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Neg#"},{"range":[11,2,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!"},{"range":[11,9,14],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!"},{"range":[11,16,20],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!"},{"range":[11,22,27],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!"},{"range":[12,11,17],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#","symbol_roles":1},{"range":[12,22,25],"symbol":"local 1"},{"range":[15,2,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!"},{"range":[15,9,14],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!"},{"range":[15,16,20],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!"},{"range":[15,22,27],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!"},{"range":[16,11,16],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#","symbol_roles":1},{"range":[16,21,24],"symbol":"local 1"},{"range":[16,30,33],"symbol":"local 1"},{"range":[25,5,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Neg#"},{"range":[25,13,19],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[26,9,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#Neg#[Output]","symbol_roles":1},{"range":[26,18,24],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[28,7,10],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#Neg#neg().","symbol_roles":1},{"range":[28,11,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 neg().(self)","symbol_roles":1},{"range":[28,20,26],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[29,8,14],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[29,16,20],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 neg().(self)"},{"range":[29,21,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[40,5,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Neg#"},{"range":[40,14,20],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[41,9,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Neg#[Output]","symbol_roles":1},{"range":[41,18,24],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[43,7,10],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Neg#neg().","symbol_roles":1},{"range":[43,11,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 neg().(self)","symbol_roles":1},{"range":[43,20,26],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[44,8,14],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[44,16,20],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 neg().(self)"},{"range":[44,21,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[57,5,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Mul#"},{"range":[57,10,16],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[57,23,28],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[58,9,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#[Output]","symbol_roles":1},{"range":[58,18,23],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[60,7,10],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul().","symbol_roles":1},{"range":[60,11,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)","symbol_roles":1},{"range":[60,17,23],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(scalar)","symbol_roles":1},{"range":[60,26,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[60,37,42],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[61,8,13],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[61,14,18],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)"},{"range":[61,19,20],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#0."},{"range":[61,23,29],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(scalar)"},{"range":[61,30,31],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[61,33,37],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)"},{"range":[61,38,39],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#1."},{"range":[61,42,48],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(scalar)"},{"range":[61,49,50],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[70,5,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Mul#"},{"range":[70,10,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[70,22,28],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[71,9,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#[Output]","symbol_roles":1},{"range":[71,18,23],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[73,7,10],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul().","symbol_roles":1},{"range":[73,11,15],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)","symbol_roles":1},{"range":[73,17,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(point)","symbol_roles":1},{"range":[73,25,30],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[73,35,40],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[74,8,13],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[74,14,18],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)"},{"range":[74,19,20],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[74,23,28],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(point)"},{"range":[74,29,30],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#0."},{"range":[74,32,36],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)"},{"range":[74,37,38],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[74,41,46],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(point)"},{"range":[74,47,48],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#1."},{"range":[83,2,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!"},{"range":[83,9,14],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!"},{"range":[84,11,20],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#","symbol_roles":1},{"range":[84,21,22],"symbol":"local 2","symbol_roles":1},{"range":[85,8,13],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#value.","symbol_roles":1},{"range":[85,15,16],"symbol":"local 2"},{"range":[89,2,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!"},{"range":[89,9,14],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!"},{"range":[89,16,21],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!"},{"range":[89,23,27],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!"},{"range":[90,11,16],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeA#","symbol_roles":1},{"range":[93,2,8],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!"},{"range":[93,9,14],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!"},{"range":[93,16,21],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!"},{"range":[93,23,27],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!"},{"range":[94,11,16],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeB#","symbol_roles":1},{"range":[101,5,9],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#"},{"range":[101,11,17],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[101,23,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[101,33,38],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeA#"},{"range":[102,7,11],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from().","symbol_roles":1},{"range":[102,12,14],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 from().(_s)","symbol_roles":1},{"range":[102,17,23],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[102,28,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[103,8,17],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[103,20,25],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#value."},{"range":[103,27,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeA#"},{"range":[112,5,9],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#"},{"range":[112,11,17],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[112,23,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[112,33,38],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeB#"},{"range":[113,7,11],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from().","symbol_roles":1},{"range":[113,12,14],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 from().(_s)","symbol_roles":1},{"range":[113,17,23],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[113,28,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[114,8,17],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[114,20,25],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#value."},{"range":[114,27,32],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeB#"},{"range":[118,2,5],"symbol":"local 3"},{"range":[119,4,9],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/","symbol_roles":1},{"range":[120,8,13],"symbol":"local 4"},{"range":[122,6,10],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!"},{"range":[123,7,21],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_neg_owned().","symbol_roles":1},{"range":[124,12,13],"symbol":"local 5","symbol_roles":1},{"range":[124,16,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[125,8,17],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!"},{"range":[125,21,22],"symbol":"local 5"},{"range":[125,24,25],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[128,6,10],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!"},{"range":[129,7,19],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_neg_ref().","symbol_roles":1},{"range":[130,12,13],"symbol":"local 6","symbol_roles":1},{"range":[130,16,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[131,8,17],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!"},{"range":[131,22,23],"symbol":"local 6"},{"range":[131,25,26],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0."},{"range":[134,6,10],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!"},{"range":[135,7,31],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_point_by_scalar().","symbol_roles":1},{"range":[136,12,13],"symbol":"local 7","symbol_roles":1},{"range":[136,16,21],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[137,12,13],"symbol":"local 8","symbol_roles":1},{"range":[137,16,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[138,12,18],"symbol":"local 9","symbol_roles":1},{"range":[138,22,23],"symbol":"local 7"},{"range":[138,27,28],"symbol":"local 8"},{"range":[139,8,17],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!"},{"range":[139,19,25],"symbol":"local 9"},{"range":[139,26,27],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#0."},{"range":[140,8,17],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!"},{"range":[140,19,25],"symbol":"local 9"},{"range":[140,26,27],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#1."},{"range":[143,6,10],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!"},{"range":[144,7,31],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_scalar_by_point().","symbol_roles":1},{"range":[145,12,13],"symbol":"local 10","symbol_roles":1},{"range":[145,16,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[146,12,13],"symbol":"local 11","symbol_roles":1},{"range":[146,16,21],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#"},{"range":[147,12,18],"symbol":"local 12","symbol_roles":1},{"range":[147,22,23],"symbol":"local 10"},{"range":[147,27,28],"symbol":"local 11"},{"range":[148,8,17],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!"},{"range":[148,19,25],"symbol":"local 12"},{"range":[148,26,27],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#0."},{"range":[149,8,17],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!"},{"range":[149,19,25],"symbol":"local 12"},{"range":[149,26,27],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#1."},{"range":[152,6,10],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!"},{"range":[153,7,38],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_a().","symbol_roles":1},{"range":[154,12,13],"symbol":"local 13","symbol_roles":1},{"range":[154,16,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[155,12,14],"symbol":"local 14","symbol_roles":1},{"range":[155,16,25],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[155,26,31],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeA#"},{"range":[155,35,44],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[155,46,50],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from()."},{"range":[155,52,53],"symbol":"local 13"},{"range":[159,6,10],"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!"},{"range":[160,7,38],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_b().","symbol_roles":1},{"range":[161,12,13],"symbol":"local 15","symbol_roles":1},{"range":[161,16,22],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#"},{"range":[162,12,14],"symbol":"local 16","symbol_roles":1},{"range":[162,16,25],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[162,26,31],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeB#"},{"range":[162,35,44],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#"},{"range":[162,46,50],"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from()."},{"range":[162,52,53],"symbol":"local 15"}],"symbols":[{"symbol":"local 0","documentation":["# The Rust Standard Library\n\nThe Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the [broader Rust\necosystem][crates.io]. It offers core types, like [`Vec<T>`] and\n[`Option<T>`], library-defined [operations on language\nprimitives](#primitives), [standard macros](#macros), [I/O] and\n[multithreading], among [many other things][other].\n\n`std` is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in [`use`] statements through the path\n`std`, as in [`use std::env`].\n\n# How to read this documentation\n\nIf you already know the name of what you are looking for, the fastest way to\nfind it is to use the <a href=\"#\" onclick=\"window.searchState.focus();\">search\nbutton</a> at the top of the page.\n\nOtherwise, you may want to jump to one of these useful sections:\n\n* [`std::*` modules](#modules)\n* [Primitive types](#primitives)\n* [Standard macros](#macros)\n* [The Rust Prelude]\n\nIf this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don't want to miss, so read on for a tour of the standard library and\nits documentation!\n\nOnce you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the\n\"<svg style=\"width:0.75rem;height:0.75rem\" viewBox=\"0 0 12 12\" stroke=\"currentColor\" fill=\"none\"><path d=\"M2,2l4,4l4,-4M2,6l4,4l4,-4\"/></svg>&nbsp;Summary\"\nbutton near the top of the page to collapse it into a more skimmable view.\n\nWhile you are looking at the top of the page, also notice the\n\"Source\" link. Rust's API documentation comes with the source\ncode and you are encouraged to read it. The standard library source is\ngenerally high quality and a peek behind the curtains is\noften enlightening.\n\n# What is in the standard library documentation?\n\nFirst of all, The Rust Standard Library is divided into a number of focused\nmodules, [all listed further down this page](#modules). These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike [`std::slice`] and [`std::cmp`]. Modules' documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.\n\nSecond, implicit methods on [primitive types] are documented here. This can\nbe a source of confusion for two reasons:\n\n1. While primitives are implemented by the compiler, the standard library\n   implements methods directly on the primitive types (and it is the only\n   library that does so), which are [documented in the section on\n   primitives](#primitives).\n2. The standard library exports many modules *with the same name as\n   primitive types*. These define additional items related to the primitive\n   type, but not the all-important methods.\n\nSo for example there is a [page for the primitive type\n`char`](primitive::char) that lists all the methods that can be called on\ncharacters (very useful), and there is a [page for the module\n`std::char`](crate::char) that documents iterator and error types created by these methods\n(rarely useful).\n\nNote the documentation for the primitives [`str`] and [`[T]`][prim@slice] (also\ncalled 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\ncalls to methods on [`str`] and [`[T]`][prim@slice] respectively, via [deref\ncoercions][deref-coercions].\n\nThird, the standard library defines [The Rust Prelude], a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.\n\nAnd finally, the standard library exports a number of standard macros, and\n[lists them on this page](#macros) (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.\n\n# Contributing changes to the documentation\n\nCheck out the Rust contribution guidelines [here](\nhttps://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation).\nThe source for this documentation can be found on\n[GitHub](https://github.com/rust-lang/rust) in the 'library/std/' directory.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.\n\nContributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on [Zulip][rust-zulip]\n#docs.\n\n# A Tour of The Rust Standard Library\n\nThe rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.\n\n## Containers and collections\n\nThe [`option`] and [`result`] modules define optional and error-handling\ntypes, [`Option<T>`] and [`Result<T, E>`]. The [`iter`] module defines\nRust's iterator trait, [`Iterator`], which works with the [`for`] loop to\naccess collections.\n\nThe standard library exposes three common ways to deal with contiguous\nregions of memory:\n\n* [`Vec<T>`] - A heap-allocated *vector* that is resizable at runtime.\n* [`[T; N]`][prim@array] - An inline *array* with a fixed size at compile time.\n* [`[T]`][prim@slice] - A dynamically sized *slice* into any other kind of contiguous\n  storage, whether heap-allocated or not.\n\nSlices can only be handled through some kind of *pointer*, and as such come\nin many flavors such as:\n\n* `&[T]` - *shared slice*\n* `&mut [T]` - *mutable slice*\n* [`Box<[T]>`][owned slice] - *owned slice*\n\n[`str`], a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust [`str`]s are typically accessed as\nimmutable references: `&str`. Use the owned [`String`] for building and\nmutating strings.\n\nFor converting to strings use the [`format!`] macro, and for converting from\nstrings use the [`FromStr`] trait.\n\nData may be shared by placing it in a reference-counted box or the [`Rc`]\ntype, and if further contained in a [`Cell`] or [`RefCell`], may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, [`Arc`], with a [`Mutex`] to get the same\neffect.\n\nThe [`collections`] module defines maps, sets, linked lists and other\ntypical collection types, including the common [`HashMap<K, V>`].\n\n## Platform abstractions and I/O\n\nBesides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.\n\nCommon types of I/O, including [files], [TCP], and [UDP], are defined in\nthe [`io`], [`fs`], and [`net`] modules.\n\nThe [`thread`] module contains Rust's threading abstractions. [`sync`]\ncontains further primitive shared memory types, including [`atomic`], [`mpmc`] and\n[`mpsc`], which contains the channel types for message passing.\n\n# Use before and after `main()`\n\nMany parts of the standard library are expected to work before and after `main()`;\nbut this is not guaranteed or ensured by tests. It is recommended that you write your own tests\nand run them on each platform you wish to support.\nThis means that use of `std` before/after main, especially of features that interact with the\nOS or global state, is exempted from stability and portability guarantees and instead only\nprovided on a best-effort basis. Nevertheless bug reports are appreciated.\n\nOn the other hand `core` and `alloc` are most likely to work in such environments with\nthe caveat that any hookable behavior such as panics, oom handling or allocators will also\ndepend on the compatibility of the hooks.\n\nSome features may also behave differently outside main, e.g. stdio could become unbuffered,\nsome panics might turn into aborts, backtraces might not get symbolicated or similar.\n\nNon-exhaustive list of known limitations:\n\n- after-main use of thread-locals, which also affects additional features:\n  - [`thread::current()`]\n- under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged\n  (they are guaranteed to be open during main,\n   and are opened to /dev/null O_RDWR if they weren't open on program start)\n\n\n[I/O]: io\n[TCP]: net::TcpStream\n[The Rust Prelude]: prelude\n[UDP]: net::UdpSocket\n[`Arc`]: sync::Arc\n[owned slice]: boxed\n[`Cell`]: cell::Cell\n[`FromStr`]: str::FromStr\n[`HashMap<K, V>`]: collections::HashMap\n[`Mutex`]: sync::Mutex\n[`Option<T>`]: option::Option\n[`Rc`]: rc::Rc\n[`RefCell`]: cell::RefCell\n[`Result<T, E>`]: result::Result\n[`Vec<T>`]: vec::Vec\n[`atomic`]: sync::atomic\n[`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n[`str`]: prim@str\n[`mpmc`]: sync::mpmc\n[`mpsc`]: sync::mpsc\n[`std::cmp`]: cmp\n[`std::slice`]: mod@slice\n[`use std::env`]: env/index.html\n[`use`]: ../book/ch07-02-defining-modules-to-control-scope-and-privacy.html\n[crates.io]: https://crates.io\n[deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n[files]: fs::File\n[multithreading]: thread\n[other]: #what-is-in-the-standard-library-documentation\n[primitive types]: ../book/ch03-02-data-types.html\n[rust-zulip]: https://rust-lang.zulipchat.com/\n[array]: prim@array\n[slice]: prim@slice"],"kind":29,"signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"extern crate std","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core ops/","documentation":["Overloadable operators.\n\nImplementing these traits allows you to overload certain operators.\n\nSome of these traits are imported by the prelude, so they are available in\nevery Rust program. Only operators backed by traits can be overloaded. For\nexample, the addition operator (`+`) can be overloaded through the [`Add`]\ntrait, but since the assignment operator (`=`) has no backing trait, there\nis no way of overloading its semantics. Additionally, this module does not\nprovide any mechanism to create new operators. If traitless overloading or\ncustom operators are required, you should look toward macros to extend\nRust's syntax.\n\nImplementations of operator traits should be unsurprising in their\nrespective contexts, keeping in mind their usual meanings and\n[operator precedence]. For example, when implementing [`Mul`], the operation\nshould have some resemblance to multiplication (and share expected\nproperties like associativity).\n\nNote that the `&&` and `||` operators are currently not supported for\noverloading. Due to their short circuiting nature, they require a different\ndesign from traits for other operators like [`BitAnd`]. Designs for them are\nunder discussion.\n\nMany of the operators take their operands by value. In non-generic\ncontexts involving built-in types, this is usually not a problem.\nHowever, using these operators in generic code, requires some\nattention if values have to be reused as opposed to letting the operators\nconsume them. One option is to occasionally use [`clone`].\nAnother option is to rely on the types involved providing additional\noperator implementations for references. For example, for a user-defined\ntype `T` which is supposed to support addition, it is probably a good\nidea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n[`Add<&T>`][`Add`] so that generic code can be written without unnecessary\ncloning.\n\n# Examples\n\nThis example creates a `Point` struct that implements [`Add`] and [`Sub`],\nand then demonstrates adding and subtracting two `Point`s.\n\n```rust\nuse std::ops::{Add, Sub};\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {x: self.x + other.x, y: self.y + other.y}\n    }\n}\n\nimpl Sub for Point {\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n        Self {x: self.x - other.x, y: self.y - other.y}\n    }\n}\n\nassert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\nassert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\n```\n\nSee the documentation for each trait for an example implementation.\n\nThe [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\ninvoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\nself` and [`FnOnce`] takes `self`. These correspond to the three kinds of\nmethods that can be invoked on an instance: call-by-reference,\ncall-by-mutable-reference, and call-by-value. The most common use of these\ntraits is to act as bounds to higher-level functions that take functions or\nclosures as arguments.\n\nTaking a [`Fn`] as a parameter:\n\n```rust\nfn call_with_one<F>(func: F) -> usize\n    where F: Fn(usize) -> usize\n{\n    func(1)\n}\n\nlet double = |x| x * 2;\nassert_eq!(call_with_one(double), 2);\n```\n\nTaking a [`FnMut`] as a parameter:\n\n```rust\nfn do_twice<F>(mut func: F)\n    where F: FnMut()\n{\n    func();\n    func();\n}\n\nlet mut x: usize = 1;\n{\n    let add_two_to_x = || x += 2;\n    do_twice(add_two_to_x);\n}\n\nassert_eq!(x, 5);\n```\n\nTaking a [`FnOnce`] as a parameter:\n\n```rust\nfn consume_with_relish<F>(func: F)\n    where F: FnOnce() -> String\n{\n    // `func` consumes its captured variables, so it cannot be run more\n    // than once\n    println!(\"Consumed: {}\", func());\n\n    println!(\"Delicious!\");\n\n    // Attempting to invoke `func()` again will throw a `use of moved\n    // value` error for `func`\n}\n\nlet x = String::from(\"x\");\nlet consume_and_return_x = move || x;\nconsume_with_relish(consume_and_return_x);\n\n// `consume_and_return_x` can no longer be invoked at this point\n```\n\n[`clone`]: Clone::clone\n[operator precedence]: ../../reference/expressions.html#expression-precedence"],"kind":29,"display_name":"ops","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"mod ops","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Mul#","documentation":["The multiplication operator `*`.\n\nNote that `Rhs` is `Self` by default, but this is not mandatory.\n\n# Examples\n\n## `Mul`tipliable rational numbers\n\n```\nuse std::ops::Mul;\n\n// By the fundamental theorem of arithmetic, rational numbers in lowest\n// terms are unique. So, by keeping `Rational`s in reduced form, we can\n// derive `Eq` and `PartialEq`.\n#[derive(Debug, Eq, PartialEq)]\nstruct Rational {\n    numerator: usize,\n    denominator: usize,\n}\n\nimpl Rational {\n    fn new(numerator: usize, denominator: usize) -> Self {\n        if denominator == 0 {\n            panic!(\"Zero is an invalid denominator!\");\n        }\n\n        // Reduce to lowest terms by dividing by the greatest common\n        // divisor.\n        let gcd = gcd(numerator, denominator);\n        Self {\n            numerator: numerator / gcd,\n            denominator: denominator / gcd,\n        }\n    }\n}\n\nimpl Mul for Rational {\n    // The multiplication of rational numbers is a closed operation.\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self {\n        let numerator = self.numerator * rhs.numerator;\n        let denominator = self.denominator * rhs.denominator;\n        Self::new(numerator, denominator)\n    }\n}\n\n// Euclid's two-thousand-year-old algorithm for finding the greatest common\n// divisor.\nfn gcd(x: usize, y: usize) -> usize {\n    let mut x = x;\n    let mut y = y;\n    while y != 0 {\n        let t = y;\n        y = x % y;\n        x = t;\n    }\n    x\n}\n\nassert_eq!(Rational::new(1, 2), Rational::new(2, 4));\nassert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n           Rational::new(1, 2));\n```\n\n## Multiplying vectors by scalars as in linear algebra\n\n```\nuse std::ops::Mul;\n\nstruct Scalar { value: usize }\n\n#[derive(Debug, PartialEq)]\nstruct Vector { value: Vec<usize> }\n\nimpl Mul<Scalar> for Vector {\n    type Output = Self;\n\n    fn mul(self, rhs: Scalar) -> Self::Output {\n        Self { value: self.value.iter().map(|v| v * rhs.value).collect() }\n    }\n}\n\nlet vector = Vector { value: vec![2, 4, 6] };\nlet scalar = Scalar { value: 3 };\nassert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\n```"],"kind":53,"display_name":"Mul","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub trait Mul<Rhs = Self>","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core arith/ops/Neg#","documentation":["The unary negation operator `-`.\n\n# Examples\n\nAn implementation of `Neg` for `Sign`, which allows the use of `-` to\nnegate its value.\n\n```\nuse std::ops::Neg;\n\n#[derive(Debug, PartialEq)]\nenum Sign {\n    Negative,\n    Zero,\n    Positive,\n}\n\nimpl Neg for Sign {\n    type Output = Self;\n\n    fn neg(self) -> Self::Output {\n        match self {\n            Sign::Negative => Sign::Positive,\n            Sign::Zero => Sign::Zero,\n            Sign::Positive => Sign::Negative,\n        }\n    }\n}\n\n// A negative positive is a negative.\nassert_eq!(-Sign::Positive, Sign::Negative);\n// A double negative is a positive.\nassert_eq!(-Sign::Negative, Sign::Positive);\n// Zero is its own negation.\nassert_eq!(-Sign::Zero, Sign::Zero);\n```"],"kind":53,"display_name":"Neg","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub trait Neg","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/derive!","documentation":["Attribute macro used to apply derive macros.\n\nSee [the reference] for more info.\n\n[the reference]: ../../../reference/attributes/derive.html"],"kind":4,"display_name":"derive","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"macro derive","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core clone/Clone!","documentation":["Derive macro generating an impl of the trait `Clone`."],"kind":4,"display_name":"Clone","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"macro Clone","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core marker/Copy!","documentation":["Derive macro generating an impl of the trait `Copy`."],"kind":4,"display_name":"Copy","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"macro Copy","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/fmt/Debug!","documentation":["Derive macro generating an impl of the trait `Debug`."],"kind":4,"display_name":"Debug","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"macro Debug","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#","documentation":["A simple scalar type for demonstration."],"kind":49,"display_name":"Scalar","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct Scalar(pub i32)","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#","documentation":["A simple point type for demonstration."],"kind":49,"display_name":"Point","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct Point(pub i32, pub i32)","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#Neg#[Output]","documentation":["The resulting type after applying the `-` operator."],"kind":3,"display_name":"Output","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"type Output = Scalar","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#Neg#neg().","documentation":["Performs the unary `-` operation.\n\n# Example\n\n```\nlet x: i32 = 12;\nassert_eq!(-x, -12);\n```"],"kind":26,"display_name":"neg","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn neg(self) -> Scalar","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 neg().(self)","kind":44,"display_name":"self","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"self: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#Neg#neg()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Scalar#0.","kind":15,"display_name":"0","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub 0: i32","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Neg#[Output]","documentation":["The resulting type after applying the `-` operator."],"kind":3,"display_name":"Output","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"type Output = Scalar","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Neg#neg().","documentation":["Performs the unary `-` operation.\n\n# Example\n\n```\nlet x: i32 = 12;\nassert_eq!(-x, -12);\n```"],"kind":26,"display_name":"neg","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn neg(self) -> Scalar","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 neg().(self)","kind":44,"display_name":"self","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"self: &Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Neg#neg()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#[Output]","documentation":["The resulting type after applying the `*` operator."],"kind":3,"display_name":"Output","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"type Output = Point","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul().","documentation":["Performs the `*` operation.\n\n# Example\n\n```\nassert_eq!(12 * 2, 24);\n```"],"kind":26,"display_name":"mul","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn mul(self, scalar: &Scalar) -> Point","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)","kind":44,"display_name":"self","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"self: &Point","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(scalar)","kind":37,"display_name":"scalar","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"scalar: &Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#0.","kind":15,"display_name":"0","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub 0: i32","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Point#1.","kind":15,"display_name":"1","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub 1: i32","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#[Output]","documentation":["The resulting type after applying the `*` operator."],"kind":3,"display_name":"Output","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"type Output = Point","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul().","documentation":["Performs the `*` operation.\n\n# Example\n\n```\nassert_eq!(12 * 2, 24);\n```"],"kind":26,"display_name":"mul","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn mul(self, point: &Point) -> Point","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(self)","kind":44,"display_name":"self","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"self: &Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 mul().(point)","kind":37,"display_name":"point","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"point: &Point","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Mul#mul()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#","documentation":["A generic container type, similar to LookupTable<T> in curve25519-dalek."],"kind":49,"display_name":"Container","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct Container<T>","position_encoding":1}},{"symbol":"local 2","kind":58,"display_name":"T","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"T","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#value.","kind":15,"display_name":"value","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub value: T","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeA#","documentation":["Marker type A (like ProjectiveNielsPoint in curve25519-dalek)."],"kind":49,"display_name":"TypeA","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct TypeA","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 TypeB#","documentation":["Marker type B (like AffineNielsPoint in curve25519-dalek)."],"kind":49,"display_name":"TypeB","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct TypeB","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core convert/From#","documentation":["Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n[`Into`].\n\nOne should always prefer implementing `From` over [`Into`]\nbecause implementing `From` automatically provides one with an implementation of [`Into`]\nthanks to the blanket implementation in the standard library.\n\nOnly implement [`Into`] when targeting a version prior to Rust 1.41 and converting to a type\noutside the current crate.\n`From` was not able to do these types of conversions in earlier versions because of Rust's\norphaning rules.\nSee [`Into`] for more details.\n\nPrefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\nto ensure that types that only implement [`Into`] can be used as well.\n\nThe `From` trait is also very useful when performing error handling. When constructing a function\nthat is capable of failing, the return type will generally be of the form `Result<T, E>`.\n`From` simplifies error handling by allowing a function to return a single error type\nthat encapsulates multiple error types. See the \"Examples\" section and [the book][book] for more\ndetails.\n\n**Note: This trait must not fail**. The `From` trait is intended for perfect conversions.\nIf the conversion can fail or is not perfect, use [`TryFrom`].\n\n# Generic Implementations\n\n- `From<T> for U` implies [`Into`]`<U> for T`\n- `From` is reflexive, which means that `From<T> for T` is implemented\n\n# When to implement `From`\n\nWhile there's no technical restrictions on which conversions can be done using\na `From` implementation, the general expectation is that the conversions\nshould typically be restricted as follows:\n\n* The conversion is *infallible*: if the conversion can fail, use [`TryFrom`]\n  instead; don't provide a `From` impl that panics.\n\n* The conversion is *lossless*: semantically, it should not lose or discard\n  information. For example, `i32: From<u16>` exists, where the original\n  value can be recovered using `u16: TryFrom<i32>`.  And `String: From<&str>`\n  exists, where you can get something equivalent to the original value via\n  `Deref`.  But `From` cannot be used to convert from `u32` to `u16`, since\n  that cannot succeed in a lossless way.  (There's some wiggle room here for\n  information not considered semantically relevant.  For example,\n  `Box<[T]>: From<Vec<T>>` exists even though it might not preserve capacity,\n  like how two vectors can be equal despite differing capacities.)\n\n* The conversion is *value-preserving*: the conceptual kind and meaning of\n  the resulting value is the same, even though the Rust type and technical\n  representation might be different.  For example `-1_i8 as u8` is *lossless*,\n  since `as` casting back can recover the original value, but that conversion\n  is *not* available via `From` because `-1` and `255` are different conceptual\n  values (despite being identical bit patterns technically).  But\n  `f32: From<i16>` *is* available because `1_i16` and `1.0_f32` are conceptually\n  the same real number (despite having very different bit patterns technically).\n  `String: From<char>` is available because they're both *text*, but\n  `String: From<u32>` is *not* available, since `1` (a number) and `\"1\"`\n  (text) are too different.  (Converting values to text is instead covered\n  by the [`Display`](crate::fmt::Display) trait.)\n\n* The conversion is *obvious*: it's the only reasonable conversion between\n  the two types.  Otherwise it's better to have it be a named method or\n  constructor, like how [`str::as_bytes`] is a method and how integers have\n  methods like [`u32::from_ne_bytes`], [`u32::from_le_bytes`], and\n  [`u32::from_be_bytes`], none of which are `From` implementations.  Whereas\n  there's only one reasonable way to wrap an [`Ipv6Addr`](crate::net::Ipv6Addr)\n  into an [`IpAddr`](crate::net::IpAddr), thus `IpAddr: From<Ipv6Addr>` exists.\n\n# Examples\n\n[`String`] implements `From<&str>`:\n\nAn explicit conversion from a `&str` to a String is done as follows:\n\n```\nlet string = \"hello\".to_string();\nlet other_string = String::from(\"hello\");\n\nassert_eq!(string, other_string);\n```\n\nWhile performing error handling it is often useful to implement `From` for your own error type.\nBy converting underlying error types to our own custom error type that encapsulates the\nunderlying error type, we can return a single error type without losing information on the\nunderlying cause. The '?' operator automatically converts the underlying error type to our\ncustom error type with `From::from`.\n\n```\nuse std::fs;\nuse std::io;\nuse std::num;\n\nenum CliError {\n    IoError(io::Error),\n    ParseError(num::ParseIntError),\n}\n\nimpl From<io::Error> for CliError {\n    fn from(error: io::Error) -> Self {\n        CliError::IoError(error)\n    }\n}\n\nimpl From<num::ParseIntError> for CliError {\n    fn from(error: num::ParseIntError) -> Self {\n        CliError::ParseError(error)\n    }\n}\n\nfn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n    let mut contents = fs::read_to_string(&file_name)?;\n    let num: i32 = contents.trim().parse()?;\n    Ok(num)\n}\n```\n\n[`String`]: ../../std/string/struct.String.html\n[`from`]: From::from\n[book]: ../../book/ch09-00-error-handling.html"],"kind":53,"display_name":"From","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub trait From<T>\nwhere\n    Self: Sized,","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from().","documentation":["Converts to this type from the input type."],"kind":80,"display_name":"from","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn from(_s: &Scalar) -> Self","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 from().(_s)","kind":37,"display_name":"_s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"_s: &Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#","documentation":["A generic container type, similar to LookupTable<T> in curve25519-dalek."],"kind":55,"signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct Container<T>","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from().","documentation":["Converts to this type from the input type."],"kind":80,"display_name":"from","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn from(_s: &Scalar) -> Self","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 from().(_s)","kind":37,"display_name":"_s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"_s: &Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#From#from()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 Container#","documentation":["A generic container type, similar to LookupTable<T> in curve25519-dalek."],"kind":55,"signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"pub struct Container<T>","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/","kind":29,"display_name":"tests","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"mod tests","position_encoding":1}},{"symbol":"local 4","documentation":["Minimal example demonstrating SCIP symbol format differences.\n\nThis crate shows four cases:\n1. Owned Self: `impl Neg for Scalar` - works correctly in both tools\n2. Reference Self: `impl Neg for &Scalar` - verus-analyzer omits the Self type\n3. Duplicate symbols (Mul): Two different `Mul` impls produce identical symbols\n4. Duplicate symbols (From): Generic type params lost, causing duplicates"],"kind":29,"signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"extern crate minimal_scip_issue","position_encoding":1}},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core builtin/macros/test!","documentation":["Attribute macro applied to a function to turn it into a unit test.\n\nSee [the reference] for more info.\n\n[the reference]: ../../../reference/attributes/testing.html#the-test-attribute"],"kind":4,"display_name":"test","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"macro test","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_neg_owned().","kind":17,"display_name":"test_neg_owned","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn test_neg_owned()","position_encoding":1}},{"symbol":"local 5","kind":61,"display_name":"s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let s: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_neg_owned()."},{"symbol":"rust-analyzer cargo core https://github.com/rust-lang/rust/library/core macros/assert_eq!","documentation":["Asserts that two expressions are equal to each other (using [`PartialEq`]).\n\nAssertions are always checked in both debug and release builds, and cannot\nbe disabled. See [`debug_assert_eq!`] for assertions that are disabled in\nrelease builds by default.\n\n[`debug_assert_eq!`]: crate::debug_assert_eq\n\nOn panic, this macro will print the values of the expressions with their\ndebug representations.\n\nLike [`assert!`], this macro has a second form, where a custom\npanic message can be provided.\n\n# Examples\n\n```\nlet a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n```"],"kind":25,"display_name":"assert_eq","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"macro_rules! assert_eq","position_encoding":1}},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_neg_ref().","kind":17,"display_name":"test_neg_ref","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn test_neg_ref()","position_encoding":1}},{"symbol":"local 6","kind":61,"display_name":"s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let s: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_neg_ref()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_point_by_scalar().","kind":17,"display_name":"test_mul_point_by_scalar","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn test_mul_point_by_scalar()","position_encoding":1}},{"symbol":"local 7","kind":61,"display_name":"p","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let p: Point","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_point_by_scalar()."},{"symbol":"local 8","kind":61,"display_name":"s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let s: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_point_by_scalar()."},{"symbol":"local 9","kind":61,"display_name":"result","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let result: Point","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_point_by_scalar()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_scalar_by_point().","kind":17,"display_name":"test_mul_scalar_by_point","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn test_mul_scalar_by_point()","position_encoding":1}},{"symbol":"local 10","kind":61,"display_name":"s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let s: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_scalar_by_point()."},{"symbol":"local 11","kind":61,"display_name":"p","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let p: Point","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_scalar_by_point()."},{"symbol":"local 12","kind":61,"display_name":"result","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let result: Point","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_mul_scalar_by_point()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_a().","kind":17,"display_name":"test_from_scalar_to_container_a","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn test_from_scalar_to_container_a()","position_encoding":1}},{"symbol":"local 13","kind":61,"display_name":"s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let s: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_a()."},{"symbol":"local 14","kind":61,"display_name":"_c","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let _c: Container<TypeA>","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_a()."},{"symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_b().","kind":17,"display_name":"test_from_scalar_to_container_b","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"fn test_from_scalar_to_container_b()","position_encoding":1}},{"symbol":"local 15","kind":61,"display_name":"s","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let s: Scalar","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_b()."},{"symbol":"local 16","kind":61,"display_name":"_c","signature_documentation":{"language":"rust","relative_path":"src/lib.rs","text":"let _c: Container<TypeB>","position_encoding":1},"enclosing_symbol":"rust-analyzer cargo minimal-scip-issue 0.1.0 tests/test_from_scalar_to_container_b()."}],"position_encoding":1}]}
